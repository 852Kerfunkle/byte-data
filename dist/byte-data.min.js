function endianness(t,r,e=0,s=t.length){if(s%r)throw Error("Bad buffer length.");for(let a=e;a<s;a+=r)swap(t,r,a)}function swap(t,r,e){r--;for(let s=0;s<r;s++){let a=t[e+s];t[e+s]=t[e+r],t[e+r]=a,r--}}function unpack(t,r=0,e=t.length){let s="";for(let a=r;a<e;){let r=128,e=191,i=!1,n=t[a++];if(n>=0&&n<=127)s+=String.fromCharCode(n);else{let o=0;n>=194&&n<=223?o=1:n>=224&&n<=239?(o=2,224===t[a]&&(r=160),237===t[a]&&(e=159)):n>=240&&n<=244?(o=3,240===t[a]&&(r=144),244===t[a]&&(e=143)):i=!0,n&=(1<<8-o-1)-1;for(let s=0;s<o;s++)(t[a]<r||t[a]>e)&&(i=!0),n=n<<6|63&t[a],a++;s+=i?"ï¿½":n<=65535?String.fromCharCode(n):String.fromCharCode(55296+((n-=65536)>>10&1023),56320+(1023&n))}}return s}function pack(t,r,e=0){for(let s=0,a=t.length;s<a;s++){let a=t.codePointAt(s);if(a<128)r[e]=a,e++;else{let t=0,i=0;for(a<=2047?(t=1,i=192):a<=65535?(t=2,i=224):a<=1114111&&(t=3,i=240,s++),r[e]=(a>>6*t)+i,e++;t>0;)r[e]=128|a>>6*(t-1)&63,e++,t--}}return e}const TYPE_ERR="Unsupported type";function validateIsInt(t){validateIsNumber(t),t==t&&t!==1/0&&t!==-1/0||throwValueErr_("integer")}function validateIsNumber(t){null==t&&throwValueErr_(),t.constructor!=Number&&t.constructor!=Boolean&&throwValueErr_()}function validateFloatType(t){if(!t||16!==t&&32!==t&&64!==t)throw Error(TYPE_ERR+": float, bits: "+t)}function validateIntType(t){if(!t||t<1||t>53)throw Error(TYPE_ERR+": int, bits: "+t)}function throwValueErr_(t="valid number"){throw Error("Argument is not a "+t)}class IEEE754Buffer{constructor(t,r){this.ebits=t,this.fbits=r,this.bias=(1<<t-1)-1,this.numBytes=Math.ceil((t+r)/8),this.biasP2=Math.pow(2,this.bias+1),this.ebitsFbits=t+r,this.fbias=Math.pow(2,-(8*this.numBytes-1-t))}pack(t,r,e){Math.abs(r)>this.biasP2-2*this.ebitsFbits&&(r=r<0?-1/0:1/0);let s=((r=+r)||1/r)<0?1:r<0?1:0,a=Math.min(Math.floor(Math.log(r=Math.abs(r))/Math.LN2),1023),i=this.roundToEven(r/Math.pow(2,a)*Math.pow(2,this.fbits));return r!=r?(i=Math.pow(2,this.fbits-1),a=(1<<this.ebits)-1):0!==r&&(r>=Math.pow(2,1-this.bias)?(i/Math.pow(2,this.fbits)>=2&&(a+=1,i=1),a>this.bias?(a=(1<<this.ebits)-1,i=0):(a+=this.bias,i=this.roundToEven(i)-Math.pow(2,this.fbits))):(i=this.roundToEven(r/Math.pow(2,1-this.bias-this.fbits)),a=0)),this.packFloatBits_(t,e,s,a,i)}unpack(t,r){let e,s=(1<<this.ebits)-1,a="";for(let e=this.numBytes-1;e>=0;e--){let s=t[e+r].toString(2);a+="00000000".substring(s.length)+s}let i="1"==a.charAt(0)?-1:1;a=a.substring(1);let n=parseInt(a.substring(0,this.ebits),2);return a=a.substring(this.ebits),n==s?0!==parseInt(a,2)?NaN:i*(1/0):(0===n?(n+=1,e=parseInt(a,2)):e=parseInt("1"+a,2),i*e*this.fbias*Math.pow(2,n-this.bias))}packFloatBits_(t,r,e,s,a){let i=[];i.push(e);for(let t=this.ebits;t>0;t-=1)i[t]=s%2?1:0,s=Math.floor(s/2);let n=i.length;for(let t=this.fbits;t>0;t-=1)i[n+t]=a%2?1:0,a=Math.floor(a/2);let o=i.join(""),h=this.numBytes+r-1,u=r;for(;h>=r;)t[h]=parseInt(o.substring(0,8),2),o=o.substring(8),h--,u++;return u}roundToEven(t){var r=Math.floor(t),e=t-r;return e<.5?r:e>.5?r+1:r%2?r+1:r}}class UintBuffer{constructor(t){this.bits=t,this.bytes=t<8?1:Math.ceil(t/8),this.max=Math.pow(2,t)-1,this.min=0;let r=8-(1+(t-1|7)-t);this.lastByteMask_=Math.pow(2,r>0?r:8)-1}pack(t,r,e=0){if(r!=r)throw Error("NaN");this.overflow(r),t[e]=255&(r<0?r+Math.pow(2,this.bits):r),e++;let s=this.bytes;for(let a=2;a<s;a++)t[e]=255&Math.floor(r/Math.pow(2,8*(a-1))),e++;return this.bits>8&&(t[e]=Math.floor(r/Math.pow(2,8*(this.bytes-1)))&this.lastByteMask_,e++),e}unpack(t,r=0){let e=this.unpackUnsafe(t,r);return this.overflow(e),e}unpackUnsafe(t,r){let e=0;for(let s=0;s<this.bytes;s++)e+=t[r+s]*Math.pow(256,s);return e}overflow(t){if(t>this.max||t<this.min)throw Error("Overflow")}}class TwosComplementBuffer extends UintBuffer{constructor(t){super(t),this.max=Math.pow(2,this.bits)/2-1,this.min=-this.max-1}pack(t,r,e=0){return super.pack(t,r,e)}unpack(t,r=0){let e=super.unpackUnsafe(t,r);return e=this.sign_(e),this.overflow(e),e}sign_(t){return t>this.max&&(t-=2*this.max+2),t}}class NumberBuffer{constructor(t,r,e){this.parser=null,r?(validateFloatType(t),this.parser=this.getFPParser_(t)):(validateIntType(t),this.parser=e?new TwosComplementBuffer(t):new UintBuffer(t),this.parser.bytes=8===this.parser.bytes?4:this.parser.bytes)}unpack(t,r=0){return this.parser.unpack(t,r)}pack(t,r,e=0){return this.parser.pack(t,r,e)}getFPParser_(t){return 16===t?new IEEE754Buffer(5,11):32===t?new IEEE754Buffer(8,23):new IEEE754Buffer(11,52)}}function unpackString(t,r=0,e=t.length){return unpack(t,r,e)}function packString(t){let r=[];return pack(t,r,0),r}function packStringTo(t,r,e=0){return pack(t,r,e)}function pack$1(t,r){let e=[];return packTo(t,r,e),e}function packTo(t,r,e,s=0){return packArrayTo([t],r,e,s)}function packArray(t,r){let e=[];return packArrayTo(t,r,e),e}function packArrayTo(t,r,e,s=0){let a=new NumberBuffer((r=r||{}).bits,r.fp,r.signed),i=offset_(r.bits),n=r.fp?validateIsNumber:validateIsInt,o=0;try{for(let h=t.length;o<h;o++){n(t[o]);let h=s+i;for(;s<h;)s=a.pack(e,t[o],s);swap_(r.be,e,i,s-i,s)}}catch(t){throw Error(t.message+" at input index "+o)}return s}function unpack$1(t,r,e=0){return unpackArray(t,r,e,e+offset_(r.bits),!0)[0]}function unpackArray(t,r,e=0,s=t.length,a=!1){let i=[];return unpackArrayTo(t,r,i,e,s,a),i}function unpackArrayTo(t,r,e,s=0,a=t.length,i=!1){let n=new NumberBuffer((r=r||{}).bits,r.fp,r.signed),o=offset_(r.bits),h=(a-s)%o;if(i&&(h||t.length<o))throw Error("Bad buffer length");a-=h;let u=0;try{swap_(r.be,t,o,s,a);for(let r=s;r<a;r+=o,u++)e[u]=n.unpack(t,r);swap_(r.be,t,o,s,a)}catch(t){throw Error(t.message+" at output index "+u)}}function swap_(t,r,e,s,a){t&&endianness(r,e,s,a)}function offset_(t){return t<8?1:Math.ceil(t/8)}export{unpackString,packString,packStringTo,pack$1 as pack,packTo,packArray,packArrayTo,unpack$1 as unpack,unpackArray,unpackArrayTo};

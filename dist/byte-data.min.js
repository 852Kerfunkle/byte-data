function endianness(t,e,r=0,n=t.length){if(n%e)throw new Error("Bad buffer length.");for(let a=r;a<n;a+=e)swap(t,e,a)}function swap(t,e,r){e--;for(let n=0;n<e;n++){let a=t[r+n];t[r+n]=t[r+e],t[r+e]=a,e--}}function utf8BufferSize(t){let e=0;for(let r=0,n=t.length;r<n;r++){let n=t.codePointAt(r);n<128?e++:(n<=2047?e++:n<=65535?e+=2:n<=1114111&&(r++,e+=3),e++)}return e}function unpack(t,e=0,r=null){r=null!==r?r+1:t.length;let n="";for(let a=e;a<r;){let e=128,r=191,o=!1,i=t[a++];if(i>=0&&i<=127)n+=String.fromCharCode(i);else{let s=0;i>=194&&i<=223?s=1:i>=224&&i<=239?(s=2,224===t[a]&&(e=160),237===t[a]&&(r=159)):i>=240&&i<=244?(s=3,240===t[a]&&(e=144),244===t[a]&&(r=143)):o=!0,i&=(1<<8-s-1)-1;for(let n=0;n<s;n++)(t[a]<e||t[a]>r)&&(o=!0),i=i<<6|63&t[a],a++;o?n+=String.fromCharCode(65533):i<=65535?n+=String.fromCharCode(i):(i-=65536,n+=String.fromCharCode(55296+(i>>10&1023),56320+(1023&i)))}}return n}function pack(t,e,r=0){for(let n=0,a=t.length;n<a;n++){let a=t.codePointAt(n);if(a<128)e[r]=a,r++;else{let t=0,o=0;for(a<=2047?(t=1,o=192):a<=65535?(t=2,o=224):a<=1114111&&(t=3,o=240,n++),e[r]=(a>>6*t)+o,r++;t>0;)e[r]=128|a>>6*(t-1)&63,r++,t--}}return r}class UintBuffer{constructor(t){this.bits=t,this.bytes=t<8?1:Math.ceil(t/8),this.max=Math.pow(2,t)-1,this.min=0;let e=8-(1+(t-1|7)-t);this.lastByteMask_=Math.pow(2,e>0?e:8)-1}pack(t,e,r=0){if(e!=e)throw new Error("NaN");this.overflow(e),t[r]=255&(e<0?e+Math.pow(2,this.bits):e),r++;let n=this.bytes;for(let a=2;a<n;a++)t[r]=255&Math.floor(e/Math.pow(2,8*(a-1))),r++;return this.bits>8&&(t[r]=Math.floor(e/Math.pow(2,8*(this.bytes-1)))&this.lastByteMask_,r++),r}unpack(t,e=0){let r=this.unpackUnsafe(t,e);return this.overflow(r),r}unpackUnsafe(t,e){let r=0;for(let n=0;n<this.bytes;n++)r+=t[e+n]*Math.pow(256,n);return r}overflow(t){if(t>this.max||t<this.min)throw new Error("Overflow")}}class TwosComplementBuffer extends UintBuffer{constructor(t){super(t),this.max=Math.pow(2,this.bits)/2-1,this.min=-this.max-1}pack(t,e,r=0){return super.pack(t,e,r)}unpack(t,e=0){let r=super.unpackUnsafe(t,e);return r=this.sign_(r),this.overflow(r),r}sign_(t){return t>this.max&&(t-=2*this.max+2),t}}class IntBuffer{constructor(t){this.parser=t.signed?new TwosComplementBuffer(t.bits):new UintBuffer(t.bits)}pack(t,e,r=0){return this.parser.pack(t,e,r)}unpack(t,e=0){return this.parser.unpack(t,e)}}const typeDefinition="Unsupported type";function validateValueType(t){if(void 0===t)throw new Error("Undefined value");if(null!==t&&t.constructor!=Number&&t.constructor!=Boolean)throw new Error("Can't pack "+t.constructor)}function validateType(t){if(!t)throw new Error(typeDefinition);t.float?validateFloatType_(t):validateIntType_(t)}function validateFloatType_(t){if(16!=t.bits&&32!=t.bits&&64!=t.bits)throw new Error(typeDefinition)}function validateIntType_(t){if(t.bits<1||t.bits>53)throw new Error(typeDefinition)}function pack$1(t,e,r,n,a){let o=(1<<n-1)-1;Math.abs(r)>Math.pow(2,o+1)-2*(n+a)&&(r=r<0?-1/0:1/0);let i=((r=+r)||1/r)<0?1:r<0?1:0;r=Math.abs(r);let s=Math.min(Math.floor(Math.log(r)/Math.LN2),1023),u=roundToEven(r/Math.pow(2,s)*Math.pow(2,a));return r!=r?(u=Math.pow(2,a-1),s=(1<<n)-1):0!==r&&(r>=Math.pow(2,1-o)?(u/Math.pow(2,a)>=2&&(s+=1,u=1),s>o?(s=(1<<n)-1,u=0):(s+=o,u=roundToEven(u)-Math.pow(2,a))):(u=roundToEven(r/Math.pow(2,1-o-a)),s=0)),packFloatBits_(t,e,n,a,i,s,u)}function unpack$1(t,e,r,n){let a,o=(1<<r-1)-1,i=Math.ceil((r+n)/8),s=(1<<r)-1,u=Math.pow(2,-(8*i-1-r)),f="";for(let r=i-1;r>=0;r--){let n=t[r+e].toString(2);f+="00000000".substring(n.length)+n}let p="1"==f.charAt(0)?-1:1;f=f.substring(1);let c=parseInt(f.substring(0,r),2);return f=f.substring(r),c==s?0!==parseInt(f,2)?NaN:p*(1/0):(0===c?(c+=1,a=parseInt(f,2)):a=parseInt("1"+f,2),p*a*u*Math.pow(2,c-o))}function packFloatBits_(t,e,r,n,a,o,i){let s=[];s.push(a);for(let t=r;t>0;t-=1)s[t]=o%2?1:0,o=Math.floor(o/2);let u=s.length;for(let t=n;t>0;t-=1)s[u+t]=i%2?1:0,i=Math.floor(i/2);let f=s.join(""),p=Math.floor((r+n+1)/8)+e-1,c=e;for(;p>=e;)t[p]=parseInt(f.substring(0,8),2),f=f.substring(8),p--,c++;return c}function roundToEven(t){var e=Math.floor(t),r=t-e;return r<.5?e:r>.5?e+1:e%2?e+1:e}class NumberBuffer extends IntBuffer{constructor(t){validateType(t),t.signed=!t.float&&t.signed,super(t),this.offset=this.parser.bytes,this.parser.bytes=64===this.parser.bits?4:this.parser.bytes,this.setReaderAndWriter_(t)}read16F_(t,e=0){return unpack$1(t,e,5,11)}read32F_(t,e=0){return unpack$1(t,e,8,23)}read64F_(t,e=0){return unpack$1(t,e,11,52)}write16F_(t,e,r=0){return pack$1(t,r,e,5,11)}write32F_(t,e,r=0){return pack$1(t,r,e,8,23)}write64F_(t,e,r=0){return pack$1(t,r,e,11,52)}setReaderAndWriter_(t){t.float?16==t.bits?(this.unpack=this.read16F_,this.pack=this.write16F_):32==t.bits?(this.unpack=this.read32F_,this.pack=this.write32F_):(this.unpack=this.read64F_,this.pack=this.write64F_):(this.unpack=super.unpack,this.pack=super.pack)}}function unpackString(t,e=0,r=null){return unpack(t,e,r)}function packString(t){let e=new Uint8Array(utf8BufferSize(t));return pack(t,e,0),e}function packStringTo(t,e,r=0){return pack(t,e,r)}function pack$2(t,e){let r=[];return packTo(t,e,r),r}function packTo(t,e,r,n=0){return packArrayTo([t],e,r,n)}function packArray(t,e){let r=[];return packArrayTo(t,e,r),r}function packArrayTo(t,e,r,n=0){let a=new NumberBuffer(e),o=t.length;for(let i=0;i<o;i++){validateValueType(t[i]);let o=n+a.offset;for(;n<o;)n=a.pack(r,t[i],n);e.be&&endianness(r,a.offset,n-a.offset,n)}return n}function unpack$2(t,e,r=0){let n=new NumberBuffer(e);if(n.offset+r>t.length)throw Error("Bad buffer length.");e.be&&endianness(t,n.offset,r,r+n.offset);let a=n.unpack(t,r);return e.be&&endianness(t,n.offset,r,r+n.offset),a}function unpackArray(t,e,r=0,n=t.length){let a=[];return unpackArrayTo(t,e,a,r,n),a}function unpackArrayTo(t,e,r,n=0,a=t.length){let o=new NumberBuffer(e),i=n;for(;(a-n)%o.offset;)a--;e.be&&endianness(t,o.offset,n,a);for(let e=0;n<a;n+=o.offset)r[e]=o.unpack(t,n),e++;e.be&&endianness(t,o.offset,i,a)}export{unpackString,packString,packStringTo,pack$2 as pack,packTo,packArray,packArrayTo,unpack$2 as unpack,unpackArray,unpackArrayTo};

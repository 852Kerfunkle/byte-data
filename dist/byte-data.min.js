function endianness(t,r,e=0,n=t.length){if(n%r)throw Error("Bad buffer length.");for(let a=e;a<n;a+=r)swap(t,r,a)}function swap(t,r,e){r--;for(let n=0;n<r;n++){let a=t[e+n];t[e+n]=t[e+r],t[e+r]=a,r--}}function unpack(t,r=0,e=null){e=null!==e?e+1:t.length;let n="";for(let a=r;a<e;){let r=128,e=191,o=!1,i=t[a++];if(i>=0&&i<=127)n+=String.fromCharCode(i);else{let s=0;i>=194&&i<=223?s=1:i>=224&&i<=239?(s=2,224===t[a]&&(r=160),237===t[a]&&(e=159)):i>=240&&i<=244?(s=3,240===t[a]&&(r=144),244===t[a]&&(e=143)):o=!0,i&=(1<<8-s-1)-1;for(let n=0;n<s;n++)(t[a]<r||t[a]>e)&&(o=!0),i=i<<6|63&t[a],a++;n+=o?"ï¿½":i<=65535?String.fromCharCode(i):String.fromCharCode(55296+((i-=65536)>>10&1023),56320+(1023&i))}}return n}function pack(t,r,e=0){for(let n=0,a=t.length;n<a;n++){let a=t.codePointAt(n);if(a<128)r[e]=a,e++;else{let t=0,o=0;for(a<=2047?(t=1,o=192):a<=65535?(t=2,o=224):a<=1114111&&(t=3,o=240,n++),r[e]=(a>>6*t)+o,e++;t>0;)r[e]=128|a>>6*(t-1)&63,e++,t--}}return e}const TYPE_ERR="Unsupported type";function validateIsInt(t){validateIsNumber(t),t==t&&t!==1/0&&t!==-1/0||throwValueErr_("integer")}function validateIsNumber(t){null==t&&throwValueErr_(),t.constructor!=Number&&t.constructor!=Boolean&&throwValueErr_()}function validateFloatType(t){if(!t||16!==t&&32!==t&&64!==t)throw Error(TYPE_ERR+": float, bits: "+t)}function validateIntType(t){if(!t||t<1||t>53)throw Error(TYPE_ERR+": int, bits: "+t)}function throwValueErr_(t="valid number"){throw Error("Argument is not a "+t)}function pack$1(t,r,e,n,a){let o=(1<<n-1)-1;Math.abs(e)>Math.pow(2,o+1)-2*(n+a)&&(e=e<0?-1/0:1/0);let i=((e=+e)||1/e)<0?1:e<0?1:0,s=Math.min(Math.floor(Math.log(e=Math.abs(e))/Math.LN2),1023),u=roundToEven(e/Math.pow(2,s)*Math.pow(2,a));return e!=e?(u=Math.pow(2,a-1),s=(1<<n)-1):0!==e&&(e>=Math.pow(2,1-o)?(u/Math.pow(2,a)>=2&&(s+=1,u=1),s>o?(s=(1<<n)-1,u=0):(s+=o,u=roundToEven(u)-Math.pow(2,a))):(u=roundToEven(e/Math.pow(2,1-o-a)),s=0)),packFloatBits_(t,r,n,a,i,s,u)}function unpack$1(t,r,e,n){let a,o=(1<<e-1)-1,i=Math.ceil((e+n)/8),s=(1<<e)-1,u=Math.pow(2,-(8*i-1-e)),f="";for(let e=i-1;e>=0;e--){let n=t[e+r].toString(2);f+="00000000".substring(n.length)+n}let c="1"==f.charAt(0)?-1:1;f=f.substring(1);let p=parseInt(f.substring(0,e),2);return f=f.substring(e),p==s?0!==parseInt(f,2)?NaN:c*(1/0):(0===p?(p+=1,a=parseInt(f,2)):a=parseInt("1"+f,2),c*a*u*Math.pow(2,p-o))}function packFloatBits_(t,r,e,n,a,o,i){let s=[];s.push(a);for(let t=e;t>0;t-=1)s[t]=o%2?1:0,o=Math.floor(o/2);let u=s.length;for(let t=n;t>0;t-=1)s[u+t]=i%2?1:0,i=Math.floor(i/2);let f=s.join(""),c=Math.floor((e+n+1)/8)+r-1,p=r;for(;c>=r;)t[c]=parseInt(f.substring(0,8),2),f=f.substring(8),c--,p++;return p}function roundToEven(t){var r=Math.floor(t),e=t-r;return e<.5?r:e>.5?r+1:r%2?r+1:r}class UintBuffer{constructor(t){this.bits=t,this.bytes=t<8?1:Math.ceil(t/8),this.max=Math.pow(2,t)-1,this.min=0;let r=8-(1+(t-1|7)-t);this.lastByteMask_=Math.pow(2,r>0?r:8)-1}pack(t,r,e=0){if(r!=r)throw Error("NaN");this.overflow(r),t[e]=255&(r<0?r+Math.pow(2,this.bits):r),e++;let n=this.bytes;for(let a=2;a<n;a++)t[e]=255&Math.floor(r/Math.pow(2,8*(a-1))),e++;return this.bits>8&&(t[e]=Math.floor(r/Math.pow(2,8*(this.bytes-1)))&this.lastByteMask_,e++),e}unpack(t,r=0){let e=this.unpackUnsafe(t,r);return this.overflow(e),e}unpackUnsafe(t,r){let e=0;for(let n=0;n<this.bytes;n++)e+=t[r+n]*Math.pow(256,n);return e}overflow(t){if(t>this.max||t<this.min)throw Error("Overflow")}}class TwosComplementBuffer extends UintBuffer{constructor(t){super(t),this.max=Math.pow(2,this.bits)/2-1,this.min=-this.max-1}pack(t,r,e=0){return super.pack(t,r,e)}unpack(t,r=0){let e=super.unpackUnsafe(t,r);return e=this.sign_(e),this.overflow(e),e}sign_(t){return t>this.max&&(t-=2*this.max+2),t}}class NumberBuffer{constructor(t,r,e){r?validateFloatType(t):validateIntType(t),this.IntBuffer=e?new TwosComplementBuffer(t):new UintBuffer(t),this.IntBuffer.bytes=8===this.IntBuffer.bytes?4:this.IntBuffer.bytes,r&&this.setFPReaderAndWriter_(t)}unpack(t,r=0){return this.IntBuffer.unpack(t,r)}pack(t,r,e=0){return this.IntBuffer.pack(t,r,e)}read16F_(t,r=0){return unpack$1(t,r,5,11)}read32F_(t,r=0){return unpack$1(t,r,8,23)}read64F_(t,r=0){return unpack$1(t,r,11,52)}write16F_(t,r,e=0){return pack$1(t,e,r,5,11)}write32F_(t,r,e=0){return pack$1(t,e,r,8,23)}write64F_(t,r,e=0){return pack$1(t,e,r,11,52)}setFPReaderAndWriter_(t){16===t?(this.unpack=this.read16F_,this.pack=this.write16F_):32===t?(this.unpack=this.read32F_,this.pack=this.write32F_):(this.unpack=this.read64F_,this.pack=this.write64F_)}}function unpackString(t,r=0,e=null){return unpack(t,r,e)}function packString(t){let r=[];return pack(t,r,0),r}function packStringTo(t,r,e=0){return pack(t,r,e)}function pack$2(t,r){let e=[];return packTo(t,r,e),e}function packTo(t,r,e,n=0){return packArrayTo([t],r,e,n)}function packArray(t,r){let e=[];return packArrayTo(t,r,e),e}function packArrayTo(t,r,e,n=0){let a=new NumberBuffer((r=r||{}).bits,r.fp,r.signed),o=offset_(r.bits),i=r.fp?validateIsNumber:validateIsInt,s=0;try{for(let u=t.length;s<u;s++){i(t[s]);let u=n+o;for(;n<u;)n=a.pack(e,t[s],n);swap_(r.be,e,o,n-o,n)}}catch(t){throw Error(t.message+" at input index "+s)}return n}function unpack$2(t,r,e=0){return unpackArray(t,r,e,e+offset_(r.bits),!0)[0]}function unpackArray(t,r,e=0,n=t.length,a=!1){let o=[];return unpackArrayTo(t,r,o,e,n,a),o}function unpackArrayTo(t,r,e,n=0,a=t.length,o=!1){let i=new NumberBuffer((r=r||{}).bits,r.fp,r.signed),s=offset_(r.bits),u=(a-n)%s;if(o&&(u||t.length<s))throw Error("Bad buffer length");a-=u,swap_(r.be,t,s,n,a);for(let r=n,o=0;r<a;r+=s,o++)e[o]=i.unpack(t,r);swap_(r.be,t,s,n,a)}function swap_(t,r,e,n,a){t&&endianness(r,e,n,a)}function offset_(t){return t<8?1:Math.ceil(t/8)}export{unpackString,packString,packStringTo,pack$2 as pack,packTo,packArray,packArrayTo,unpack$2 as unpack,unpackArray,unpackArrayTo};

function endianness(t,e,r=0,n=t.length){if(n%e)throw new Error("Bad buffer length.");for(let i=r;i<n;i+=e)swap(t,e,i)}function swap(t,e,r){e--;for(let n=0;n<e;n++){let i=t[r+n];t[r+n]=t[r+e],t[r+e]=i,e--}}function utf8BufferSize(t){let e=0;for(let r=0,n=t.length;r<n;r++){let n=t.codePointAt(r);n<128?e++:(n<=2047?e++:n<=65535?e+=2:n<=1114111&&(r++,e+=3),e++)}return e}function unpack(t,e=0,r=null){r=null!==r?r+1:t.length;let n="";for(let i=e;i<r;){let e=128,r=191,a=!1,s=t[i++];if(s>=0&&s<=127)n+=String.fromCharCode(s);else{let o=0;s>=194&&s<=223?o=1:s>=224&&s<=239?(o=2,224===t[i]&&(e=160),237===t[i]&&(r=159)):s>=240&&s<=244?(o=3,240===t[i]&&(e=144),244===t[i]&&(r=143)):a=!0,s&=(1<<8-o-1)-1;for(let n=0;n<o;n++)(t[i]<e||t[i]>r)&&(a=!0),s=s<<6|63&t[i],i++;a?n+=String.fromCharCode(65533):s<=65535?n+=String.fromCharCode(s):(s-=65536,n+=String.fromCharCode(55296+(s>>10&1023),56320+(1023&s)))}}return n}function pack(t,e,r=0){for(let n=0,i=t.length;n<i;n++){let i=t.codePointAt(n);if(i<128)e[r]=i,r++;else{let t=0,a=0;for(i<=2047?(t=1,a=192):i<=65535?(t=2,a=224):i<=1114111&&(t=3,a=240,n++),e[r]=(i>>6*t)+a,r++;t>0;)e[r]=128|i>>6*(t-1)&63,r++,t--}}return r}class UintBuffer{constructor(t){this.bits=t,this.bytes=t<8?1:Math.ceil(t/8),this.max=Math.pow(2,t)-1,this.min=0;let e=8-(1+(t-1|7)-t);this.lastByteMask_=Math.pow(2,e>0?e:8)-1}pack(t,e,r=0){if(e!=e)throw new Error("NaN");this.overflow(e),t[r]=255&(e<0?e+Math.pow(2,this.bits):e),r++;let n=this.bytes;for(let i=2;i<n;i++)t[r]=255&Math.floor(e/Math.pow(2,8*(i-1))),r++;return this.bits>8&&(t[r]=Math.floor(e/Math.pow(2,8*(this.bytes-1)))&this.lastByteMask_,r++),r}unpack(t,e=0){let r=this.unpackUnsafe(t,e);return this.overflow(r),r}unpackUnsafe(t,e){let r=0;for(let n=0;n<this.bytes;n++)r+=t[e+n]*Math.pow(256,n);return r}overflow(t){if(t>this.max||t<this.min)throw new Error("Overflow")}}class TwosComplementBuffer extends UintBuffer{constructor(t){super(t),this.max=Math.pow(2,this.bits)/2-1,this.min=-this.max-1}pack(t,e,r=0){return super.pack(t,e,r)}unpack(t,e=0){let r=super.unpackUnsafe(t,e);return r=this.sign_(r),this.overflow(r),r}sign_(t){return t>this.max&&(t-=2*this.max+2),t}}class IntBuffer{constructor(t){this.parser=null,t.signed?this.parser=new TwosComplementBuffer(t.bits):this.parser=new UintBuffer(t.bits)}pack(t,e,r=0){return this.parser.pack(t,e,r)}unpack(t,e=0){return this.parser.unpack(t,e)}}function validateValueType(t){if(null!==t&&t.constructor!=Number&&t.constructor!=Boolean)throw new Error("Expected Number, Boolean or Null; found "+t.constructor)}function validateNotUndefined(t){if(void 0===t)throw new Error("Undefined value.")}function validateType(t){if(!t)throw new Error("Undefined type.");t.float?validateFloatType_(t):validateIntType_(t)}function validateFloatType_(t){if(16!=t.bits&&32!=t.bits&&64!=t.bits)throw new Error("Bad float type.")}function validateIntType_(t){if(t.bits<1||t.bits>53)throw new Error("Bad type definition.")}function pack$1(t,e,r,n,i){let a=(1<<n-1)-1;Math.abs(r)>Math.pow(2,a+1)-2*(n+i)&&(r=r<0?-1/0:1/0);let s=((r=+r)||1/r)<0?1:r<0?1:0;r=Math.abs(r);let o=Math.min(Math.floor(Math.log(r)/Math.LN2),1023),u=roundToEven(r/Math.pow(2,o)*Math.pow(2,i));return r!=r?(u=Math.pow(2,i-1),o=(1<<n)-1):0!==r&&(r>=Math.pow(2,1-a)?(u/Math.pow(2,i)>=2&&(o+=1,u=1),o>a?(o=(1<<n)-1,u=0):(o+=a,u=roundToEven(u)-Math.pow(2,i))):(u=roundToEven(r/Math.pow(2,1-a-i)),o=0)),packFloatBits_(t,e,n,i,s,o,u)}function unpack$1(t,e,r,n){let i,a=(1<<r-1)-1,s=Math.ceil((r+n)/8),o=(1<<r)-1,u=Math.pow(2,-(8*s-1-r)),f="";for(let r=s-1;r>=0;r--){let n=t[r+e].toString(2);f+="00000000".substring(n.length)+n}let h="1"==f.charAt(0)?-1:1;f=f.substring(1);let p=parseInt(f.substring(0,r),2);return f=f.substring(r),p==o?0!==parseInt(f,2)?NaN:h*(1/0):(0===p?(p+=1,i=parseInt(f,2)):i=parseInt("1"+f,2),h*i*u*Math.pow(2,p-a))}function packFloatBits_(t,e,r,n,i,a,s){let o=[];o.push(i);for(let t=r;t>0;t-=1)o[t]=a%2?1:0,a=Math.floor(a/2);let u=o.length;for(let t=n;t>0;t-=1)o[u+t]=s%2?1:0,s=Math.floor(s/2);let f=o.join(""),h=Math.floor((r+n+1)/8)+e-1,p=e;for(;h>=e;)t[h]=parseInt(f.substring(0,8),2),f=f.substring(8),h--,p++;return p}function roundToEven(t){var e=Math.floor(t),r=t-e;return r<.5?e:r>.5?e+1:e%2?e+1:e}class NumberBuffer extends IntBuffer{constructor(t){validateType(t),t.signed=!t.float&&t.signed,super(t),this.offset=this.parser.bytes,this.parser.bytes=64===this.parser.bits?4:this.parser.bytes,this.TYPED="function"==typeof Uint8Array,this.HIGH_=this.beEnv_()?1:0,this.LOW_=this.HIGH_?0:1;let e=this.TYPED?new Uint8Array(8):null;this.ui32_=this.TYPED?new Uint32Array(e.buffer):null,this.f32_=this.TYPED?new Float32Array(e.buffer):null,this.f64_=this.TYPED?new Float64Array(e.buffer):null,this.setReaderAndWriter_(t)}beEnv_(){return!!this.TYPED&&0===new Uint8Array(new Uint32Array([1]).buffer)[0]}read16F_(t,e=0){return unpack$1(t,e,5,11)}read32F_(t,e=0){return unpack$1(t,e,8,23)}read32FTyped_(t,e=0){return this.ui32_[0]=super.unpack(t,e),this.f32_[0]}read64F_(t,e=0){return unpack$1(t,e,11,52)}read64FTyped_(t,e=0){return this.ui32_[this.HIGH_]=super.unpack(t,e),this.ui32_[this.LOW_]=super.unpack(t,e+4),this.f64_[0]}write16F_(t,e,r=0){return pack$1(t,r,e,5,11)}write32F_(t,e,r=0){return pack$1(t,r,e,8,23)}write32FTyped_(t,e,r=0){return e!=e?this.write32F_(t,e,r):(this.f32_[0]=e,super.pack(t,this.ui32_[0],r))}write64F_(t,e,r=0){return pack$1(t,r,e,11,52)}write64FTyped_(t,e,r=0){return e!=e?this.write64F_(t,e,r):(this.f64_[0]=e,r=super.pack(t,this.ui32_[this.HIGH_],r),super.pack(t,this.ui32_[this.LOW_],r))}setReaderAndWriter_(t){t.float?16==t.bits?(this.unpack=this.read16F_,this.pack=this.write16F_):32==t.bits?(this.unpack=this.TYPED?this.read32FTyped_:this.read32F_,this.pack=this.TYPED?this.write32FTyped_:this.write32F_):(this.unpack=this.TYPED?this.read64FTyped_:this.read64F_,this.pack=this.TYPED?this.write64FTyped_:this.write64F_):(this.unpack=super.unpack,this.pack=super.pack)}}function unpackString(t,e=0,r=null){return unpack(t,e,r)}function packString(t){let e;return pack(t,e="function"==typeof Uint8Array?new Uint8Array(utf8BufferSize(t)):[],0),e}function packStringTo(t,e,r=0){return pack(t,e,r)}function pack$2(t,e){let r=[];return packTo(t,e,r),r}function packTo(t,e,r,n=0){return packArrayTo([t],e,r,n)}function packArray(t,e){let r=[];return packArrayTo(t,e,r),r}function packArrayTo(t,e,r,n=0){let i=new NumberBuffer(e),a=t.length;for(let s=0;s<a;s++){validateNotUndefined(t[s]),validateValueType(t[s]);let a=n+i.offset;for(;n<a;)n=i.pack(r,t[s],n);e.be&&endianness(r,i.offset,n-i.offset,n)}return n}function unpack$2(t,e,r=0){let n=new NumberBuffer(e);if(n.offset+r>t.length)throw Error("Bad buffer length.");e.be&&endianness(t,n.offset,r,r+n.offset);let i=n.unpack(t,r);return e.be&&endianness(t,n.offset,r,r+n.offset),i}function unpackArray(t,e,r=0,n=t.length){let i=[];return unpackArrayTo(t,e,i,r,n),i}function unpackArrayTo(t,e,r,n=0,i=t.length){let a=new NumberBuffer(e),s=n;for(;(i-n)%a.offset;)i--;e.be&&endianness(t,a.offset,n,i);for(let e=0;n<i;n+=a.offset)r[e]=a.unpack(t,n),e++;e.be&&endianness(t,a.offset,s,i)}export{unpackString,packString,packStringTo,pack$2 as pack,packTo,packArray,packArrayTo,unpack$2 as unpack,unpackArray,unpackArrayTo};

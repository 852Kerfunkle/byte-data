"use strict";function endianness(t,e,r=0,i=t.length){if(i%e)throw new Error("Bad buffer length.");for(;r<i;r+=e)swap(t,e,r)}function swap(t,e,r){e--;for(let i=0;i<e;i++){let n=t[r+i];t[r+i]=t[r+e],t[r+e]=n,e--}}Object.defineProperty(exports,"__esModule",{value:!0});class Integer{constructor(){this.offset=0,this.realOffset_=0,this.bits_=0,this.lastByteMask_=0,this.max_=0,this.min_=0}setUp(t){this.bits_=t.bits;let e=Math.pow(2,this.bits_);t.signed?(this.max_=e/2-1,this.min_=-e/2):(this.max_=e-1,this.min_=0),this.setLastByteMask_(),this.offset=this.bits_<8?1:Math.ceil(this.bits_/8),this.realOffset_=64===this.bits_?4:this.offset}read(t,e=0){let r=0;for(let i=0;i<this.realOffset_;i++)r+=t[e+i]*Math.pow(256,i);return r=this.sign_(r),this.overflow_(r),r}write(t,e,r=0){if(e!=e)throw new Error("NaN");this.overflow_(e),t[r]=255&(e<0?e+Math.pow(2,this.bits_):e),r++;let i=this.realOffset_;for(let n=2;n<i;n++)t[r]=255&Math.floor(e/Math.pow(2,8*(n-1))),r++;return this.bits_>8&&(t[r]=Math.floor(e/Math.pow(2,8*(this.realOffset_-1)))&this.lastByteMask_,r++),r}sign_(t){return t>this.max_&&(t-=2*this.max_+2),t}overflow_(t){if(t>this.max_||t<this.min_)throw new Error("Integer overflow")}setLastByteMask_(){let t=8-(1+(this.bits_-1|7)-this.bits_);this.lastByteMask_=Math.pow(2,t>0?t:8)-1}}function validateValueType(t){if(null!==t&&t.constructor!=Number&&t.constructor!=Boolean)throw new Error("Expected Number, Boolean or Null; found "+t.constructor)}function validateNotUndefined(t){if(void 0===t)throw new Error("Undefined value.")}function validateType(t){if(!t)throw new Error("Undefined type.");t.float?validateFloatType_(t):validateIntType_(t)}function validateFloatType_(t){if(16!=t.bits&&32!=t.bits&&64!=t.bits)throw new Error("Bad float type.")}function validateIntType_(t){if(t.bits<1||t.bits>53)throw new Error("Bad type definition.")}function roundToEven(t){var e=Math.floor(t),r=t-e;return r<.5?e:r>.5?e+1:e%2?e+1:e}function pack(t,e,r,i,n){let a=(1<<i-1)-1;Math.abs(r)>Math.pow(2,a+1)-2*(i+n)&&(r=r<0?-1/0:1/0);let s=((r=+r)||1/r)<0?1:r<0?1:0;r=Math.abs(r);let o=Math.min(Math.floor(Math.log(r)/Math.LN2),1023),f=roundToEven(r/Math.pow(2,o)*Math.pow(2,n));return r!=r?(f=Math.pow(2,n-1),o=(1<<i)-1):0!==r&&(r>=Math.pow(2,1-a)?(f/Math.pow(2,n)>=2&&(o+=1,f=1),o>a?(o=roundToEven(1<<i)-1,f=0):(o+=a,f=roundToEven(f)-Math.pow(2,n))):(f=roundToEven(r/Math.pow(2,1-a-n)),o=0)),packFloatBits_(t,e,i,n,s,o,f)}function unpack(t,e,r,i){let n,a=(1<<r-1)-1,s=Math.ceil((r+i)/8),o=(1<<r)-1,f=Math.pow(2,-(8*s-1-r)),h="";for(let r=s-1;r>=0;r--){let i=t[r+e].toString(2);h+="00000000".substring(i.length)+i}let p="1"==h.charAt(0)?-1:1;h=h.substring(1);let u=parseInt(h.substring(0,r),2);return h=h.substring(r),u==o?0!==parseInt(h,2)?NaN:p*(1/0):(0==u?(u+=1,n=parseInt(h,2)):n=parseInt("1"+h,2),p*n*f*Math.pow(2,u-a))}function packFloatBits_(t,e,r,i,n,a,s){let o=[];o.push(n);for(let t=r;t>0;t-=1)o[t]=a%2?1:0,a=Math.floor(a/2);let f=o.length;for(let t=i;t>0;t-=1)o[f+t]=s%2?1:0,s=Math.floor(s/2);let h=o.join(""),p=Math.ceil((r+i+1)/8)+e-1;p=2==p?1:p;let u=e;for(;p>=e;)t[p]=parseInt(h.substring(0,8),2),h=h.substring(8),p--,u++;return u}class Packer extends Integer{constructor(){super(),this.TYPED="function"==typeof Uint8Array;let t=!1;this.TYPED&&(t=0===new Uint8Array(new Uint32Array([1]).buffer)[0]),this.HIGH_=t?1:0,this.LOW_=t?0:1;let e=this.TYPED?new Uint8Array(8):null;this.ui32_=this.TYPED?new Uint32Array(e.buffer):null,this.f32_=this.TYPED?new Float32Array(e.buffer):null,this.f64_=this.TYPED?new Float64Array(e.buffer):null}setUp(t){validateType(t),super.setUp({bits:t.bits,signed:!t.float&&t.signed}),this.setReaderAndWriter_(t)}read16F_(t,e=0){return unpack(t,e,5,11)}read32F_(t,e=0){return unpack(t,e,8,23)}read32FTyped_(t,e=0){return this.ui32_[0]=super.read(t,e),this.f32_[0]}read64F_(t,e=0){return unpack(t,e,11,52)}read64FTyped_(t,e=0){return this.ui32_[this.HIGH_]=super.read(t,e),this.ui32_[this.LOW_]=super.read(t,e+4),this.f64_[0]}write16F_(t,e,r=0){return pack(t,r,e,5,11)}write32F_(t,e,r=0){return pack(t,r,e,8,23)}write32FTyped_(t,e,r=0){return e!=e?this.write32F_(t,e,r):(this.f32_[0]=e,super.write(t,this.ui32_[0],r))}write64F_(t,e,r=0){return pack(t,r,e,11,52)}write64FTyped_(t,e,r=0){return e!=e?this.write64F_(t,e,r):(this.f64_[0]=e,r=super.write(t,this.ui32_[this.HIGH_],r),super.write(t,this.ui32_[this.LOW_],r))}setReaderAndWriter_(t){t.float?16==t.bits?(this.read=this.read16F_,this.write=this.write16F_):32==t.bits?(this.read=this.TYPED?this.read32FTyped_:this.read32F_,this.write=this.TYPED?this.write32FTyped_:this.write32F_):(this.read=this.TYPED?this.read64FTyped_:this.read64F_,this.write=this.TYPED?this.write64FTyped_:this.write64F_):(this.read=super.read,this.write=super.write)}}function utf8BufferSize(t){let e=0;for(let r=0,i=t.length;r<i;r++){let i=t.codePointAt(r);i<128?e++:(i<=2047?e++:i<=65535?e+=2:i<=1114111&&(r++,e+=3),e++)}return e}function unpack$1(t,e=0,r){r=void 0!==r?e+r:t.length;let i="";for(;e<r;){let r=128,n=191,a=!1,s=t[e++];if(s>=0&&s<=127)i+=String.fromCharCode(s);else{let o=0;s>=194&&s<=223?o=1:s>=224&&s<=239?(o=2,224===t[e]&&(r=160),237===t[e]&&(n=159)):s>=240&&s<=244?(o=3,240===t[e]&&(r=144),244===t[e]&&(n=143)):a=!0,s&=(1<<8-o-1)-1;for(let i=0;i<o;i++)(t[e]<r||t[e]>n)&&(a=!0),s=s<<6|63&t[e],e++;a?i+=String.fromCharCode(65533):s<=65535?i+=String.fromCharCode(s):(s-=65536,i+=String.fromCharCode(55296+(s>>10&1023),56320+(1023&s)))}}return i}function pack$1(t){let e;e="undefined"!=typeof Uint8Array?new Uint8Array(utf8BufferSize(t)):[];let r=0;for(let i=0,n=t.length;i<n;i++){let n=t.codePointAt(i);if(n<128)e[r]=n,r++;else{let t=0,a=0;for(n<=2047?(t=1,a=192):n<=65535?(t=2,a=224):n<=1114111&&(t=3,a=240,i++),e[r]=(n>>6*t)+a,r++;t>0;)e[r]=128|n>>6*(t-1)&63,r++,t--}}return e}let packer=new Packer;function unpackString(t,e=0,r){return unpack$1(t,e,r)}function packString(t){return pack$1(t)}function packStringTo(t,e,r=0){let i=packString(t),n=i.length;for(let t=0;t<n;t++)e[r++]=i[t];return r}function pack$2(t,e){let r=[];return packTo(t,e,r),r}function packTo(t,e,r,i=0){return packArrayTo([t],e,r,i)}function packArray(t,e){let r=[];return packArrayTo(t,e,r),r}function packArrayTo(t,e,r,i=0){packer.setUp(e);let n=t.length;for(let a=0;a<n;a++){validateNotUndefined(t[a]),validateValueType(t[a]);let n=i+packer.offset;for(;i<n;)i=packer.write(r,t[a],i);e.be&&endianness(r,packer.offset,i-packer.offset,i)}return i}function unpack$2(t,e,r=0){if(packer.setUp(e),packer.offset+r>t.length)throw Error("Bad buffer length.");e.be&&endianness(t,packer.offset,r,r+packer.offset);let i=packer.read(t,r);return e.be&&endianness(t,packer.offset,r,r+packer.offset),i}function unpackArray(t,e,r=0,i=t.length){let n=[];return unpackArrayTo(t,e,n,r,i),n}function unpackArrayTo(t,e,r,i=0,n=t.length){packer.setUp(e);let a=i;for(;(n-i)%packer.offset;)n--;e.be&&endianness(t,packer.offset,i,n);for(let e=0;i<n;i+=packer.offset)r[e]=packer.read(t,i),e++;e.be&&endianness(t,packer.offset,a,n)}exports.unpackString=unpackString,exports.packString=packString,exports.packStringTo=packStringTo,exports.pack=pack$2,exports.packTo=packTo,exports.packArray=packArray,exports.packArrayTo=packArrayTo,exports.unpack=unpack$2,exports.unpackArray=unpackArray,exports.unpackArrayTo=unpackArrayTo;
